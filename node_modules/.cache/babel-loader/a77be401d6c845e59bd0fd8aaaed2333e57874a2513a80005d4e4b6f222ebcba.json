{"ast":null,"code":"import { bufferToBase64URLString } from '../helpers/bufferToBase64URLString.js';\nimport { base64URLStringToBuffer } from '../helpers/base64URLStringToBuffer.js';\nimport { browserSupportsWebAuthn } from '../helpers/browserSupportsWebAuthn.js';\nimport { browserSupportsWebAuthnAutofill } from '../helpers/browserSupportsWebAuthnAutofill.js';\nimport { toPublicKeyCredentialDescriptor } from '../helpers/toPublicKeyCredentialDescriptor.js';\nimport { identifyAuthenticationError } from '../helpers/identifyAuthenticationError.js';\nimport { WebAuthnAbortService } from '../helpers/webAuthnAbortService.js';\nimport { toAuthenticatorAttachment } from '../helpers/toAuthenticatorAttachment.js';\n/**\n * Begin authenticator \"login\" via WebAuthn assertion\n *\n * @param optionsJSON Output from **@simplewebauthn/server**'s `generateAuthenticationOptions()`\n * @param useBrowserAutofill (Optional) Initialize conditional UI to enable logging in via browser autofill prompts. Defaults to `false`.\n * @param verifyBrowserAutofillInput (Optional) Ensure a suitable `<input>` element is present when `useBrowserAutofill` is `true`. Defaults to `true`.\n */\nexport async function startAuthentication(options) {\n  const {\n    optionsJSON,\n    useBrowserAutofill = false,\n    verifyBrowserAutofillInput = true\n  } = options;\n  if (!browserSupportsWebAuthn()) {\n    throw new Error('WebAuthn is not supported in this browser');\n  }\n  // We need to avoid passing empty array to avoid blocking retrieval\n  // of public key\n  let allowCredentials;\n  if (optionsJSON.allowCredentials?.length !== 0) {\n    allowCredentials = optionsJSON.allowCredentials?.map(toPublicKeyCredentialDescriptor);\n  }\n  // We need to convert some values to Uint8Arrays before passing the credentials to the navigator\n  const publicKey = {\n    ...optionsJSON,\n    challenge: base64URLStringToBuffer(optionsJSON.challenge),\n    allowCredentials\n  };\n  // Prepare options for `.get()`\n  const getOptions = {};\n  /**\n   * Set up the page to prompt the user to select a credential for authentication via the browser's\n   * input autofill mechanism.\n   */\n  if (useBrowserAutofill) {\n    if (!(await browserSupportsWebAuthnAutofill())) {\n      throw Error('Browser does not support WebAuthn autofill');\n    }\n    // Check for an <input> with \"webauthn\" in its `autocomplete` attribute\n    const eligibleInputs = document.querySelectorAll(\"input[autocomplete$='webauthn']\");\n    // WebAuthn autofill requires at least one valid input\n    if (eligibleInputs.length < 1 && verifyBrowserAutofillInput) {\n      throw Error('No <input> with \"webauthn\" as the only or last value in its `autocomplete` attribute was detected');\n    }\n    // `CredentialMediationRequirement` doesn't know about \"conditional\" yet as of\n    // typescript@4.6.3\n    getOptions.mediation = 'conditional';\n    // Conditional UI requires an empty allow list\n    publicKey.allowCredentials = [];\n  }\n  // Finalize options\n  getOptions.publicKey = publicKey;\n  // Set up the ability to cancel this request if the user attempts another\n  getOptions.signal = WebAuthnAbortService.createNewAbortSignal();\n  // Wait for the user to complete assertion\n  let credential;\n  try {\n    credential = await navigator.credentials.get(getOptions);\n  } catch (err) {\n    throw identifyAuthenticationError({\n      error: err,\n      options: getOptions\n    });\n  }\n  if (!credential) {\n    throw new Error('Authentication was not completed');\n  }\n  const {\n    id,\n    rawId,\n    response,\n    type\n  } = credential;\n  let userHandle = undefined;\n  if (response.userHandle) {\n    userHandle = bufferToBase64URLString(response.userHandle);\n  }\n  // Convert values to base64 to make it easier to send back to the server\n  return {\n    id,\n    rawId: bufferToBase64URLString(rawId),\n    response: {\n      authenticatorData: bufferToBase64URLString(response.authenticatorData),\n      clientDataJSON: bufferToBase64URLString(response.clientDataJSON),\n      signature: bufferToBase64URLString(response.signature),\n      userHandle\n    },\n    type,\n    clientExtensionResults: credential.getClientExtensionResults(),\n    authenticatorAttachment: toAuthenticatorAttachment(credential.authenticatorAttachment)\n  };\n}","map":{"version":3,"names":["bufferToBase64URLString","base64URLStringToBuffer","browserSupportsWebAuthn","browserSupportsWebAuthnAutofill","toPublicKeyCredentialDescriptor","identifyAuthenticationError","WebAuthnAbortService","toAuthenticatorAttachment","startAuthentication","options","optionsJSON","useBrowserAutofill","verifyBrowserAutofillInput","Error","allowCredentials","length","map","publicKey","challenge","getOptions","eligibleInputs","document","querySelectorAll","mediation","signal","createNewAbortSignal","credential","navigator","credentials","get","err","error","id","rawId","response","type","userHandle","undefined","authenticatorData","clientDataJSON","signature","clientExtensionResults","getClientExtensionResults","authenticatorAttachment"],"sources":["/Users/rohit/Desktop/projects/FinVote/node_modules/@simplewebauthn/browser/esm/methods/startAuthentication.js"],"sourcesContent":["import { bufferToBase64URLString } from '../helpers/bufferToBase64URLString.js';\nimport { base64URLStringToBuffer } from '../helpers/base64URLStringToBuffer.js';\nimport { browserSupportsWebAuthn } from '../helpers/browserSupportsWebAuthn.js';\nimport { browserSupportsWebAuthnAutofill } from '../helpers/browserSupportsWebAuthnAutofill.js';\nimport { toPublicKeyCredentialDescriptor } from '../helpers/toPublicKeyCredentialDescriptor.js';\nimport { identifyAuthenticationError } from '../helpers/identifyAuthenticationError.js';\nimport { WebAuthnAbortService } from '../helpers/webAuthnAbortService.js';\nimport { toAuthenticatorAttachment } from '../helpers/toAuthenticatorAttachment.js';\n/**\n * Begin authenticator \"login\" via WebAuthn assertion\n *\n * @param optionsJSON Output from **@simplewebauthn/server**'s `generateAuthenticationOptions()`\n * @param useBrowserAutofill (Optional) Initialize conditional UI to enable logging in via browser autofill prompts. Defaults to `false`.\n * @param verifyBrowserAutofillInput (Optional) Ensure a suitable `<input>` element is present when `useBrowserAutofill` is `true`. Defaults to `true`.\n */\nexport async function startAuthentication(options) {\n    const { optionsJSON, useBrowserAutofill = false, verifyBrowserAutofillInput = true, } = options;\n    if (!browserSupportsWebAuthn()) {\n        throw new Error('WebAuthn is not supported in this browser');\n    }\n    // We need to avoid passing empty array to avoid blocking retrieval\n    // of public key\n    let allowCredentials;\n    if (optionsJSON.allowCredentials?.length !== 0) {\n        allowCredentials = optionsJSON.allowCredentials?.map(toPublicKeyCredentialDescriptor);\n    }\n    // We need to convert some values to Uint8Arrays before passing the credentials to the navigator\n    const publicKey = {\n        ...optionsJSON,\n        challenge: base64URLStringToBuffer(optionsJSON.challenge),\n        allowCredentials,\n    };\n    // Prepare options for `.get()`\n    const getOptions = {};\n    /**\n     * Set up the page to prompt the user to select a credential for authentication via the browser's\n     * input autofill mechanism.\n     */\n    if (useBrowserAutofill) {\n        if (!(await browserSupportsWebAuthnAutofill())) {\n            throw Error('Browser does not support WebAuthn autofill');\n        }\n        // Check for an <input> with \"webauthn\" in its `autocomplete` attribute\n        const eligibleInputs = document.querySelectorAll(\"input[autocomplete$='webauthn']\");\n        // WebAuthn autofill requires at least one valid input\n        if (eligibleInputs.length < 1 && verifyBrowserAutofillInput) {\n            throw Error('No <input> with \"webauthn\" as the only or last value in its `autocomplete` attribute was detected');\n        }\n        // `CredentialMediationRequirement` doesn't know about \"conditional\" yet as of\n        // typescript@4.6.3\n        getOptions.mediation = 'conditional';\n        // Conditional UI requires an empty allow list\n        publicKey.allowCredentials = [];\n    }\n    // Finalize options\n    getOptions.publicKey = publicKey;\n    // Set up the ability to cancel this request if the user attempts another\n    getOptions.signal = WebAuthnAbortService.createNewAbortSignal();\n    // Wait for the user to complete assertion\n    let credential;\n    try {\n        credential = (await navigator.credentials.get(getOptions));\n    }\n    catch (err) {\n        throw identifyAuthenticationError({ error: err, options: getOptions });\n    }\n    if (!credential) {\n        throw new Error('Authentication was not completed');\n    }\n    const { id, rawId, response, type } = credential;\n    let userHandle = undefined;\n    if (response.userHandle) {\n        userHandle = bufferToBase64URLString(response.userHandle);\n    }\n    // Convert values to base64 to make it easier to send back to the server\n    return {\n        id,\n        rawId: bufferToBase64URLString(rawId),\n        response: {\n            authenticatorData: bufferToBase64URLString(response.authenticatorData),\n            clientDataJSON: bufferToBase64URLString(response.clientDataJSON),\n            signature: bufferToBase64URLString(response.signature),\n            userHandle,\n        },\n        type,\n        clientExtensionResults: credential.getClientExtensionResults(),\n        authenticatorAttachment: toAuthenticatorAttachment(credential.authenticatorAttachment),\n    };\n}\n"],"mappings":"AAAA,SAASA,uBAAuB,QAAQ,uCAAuC;AAC/E,SAASC,uBAAuB,QAAQ,uCAAuC;AAC/E,SAASC,uBAAuB,QAAQ,uCAAuC;AAC/E,SAASC,+BAA+B,QAAQ,+CAA+C;AAC/F,SAASC,+BAA+B,QAAQ,+CAA+C;AAC/F,SAASC,2BAA2B,QAAQ,2CAA2C;AACvF,SAASC,oBAAoB,QAAQ,oCAAoC;AACzE,SAASC,yBAAyB,QAAQ,yCAAyC;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,eAAeC,mBAAmBA,CAACC,OAAO,EAAE;EAC/C,MAAM;IAAEC,WAAW;IAAEC,kBAAkB,GAAG,KAAK;IAAEC,0BAA0B,GAAG;EAAM,CAAC,GAAGH,OAAO;EAC/F,IAAI,CAACP,uBAAuB,CAAC,CAAC,EAAE;IAC5B,MAAM,IAAIW,KAAK,CAAC,2CAA2C,CAAC;EAChE;EACA;EACA;EACA,IAAIC,gBAAgB;EACpB,IAAIJ,WAAW,CAACI,gBAAgB,EAAEC,MAAM,KAAK,CAAC,EAAE;IAC5CD,gBAAgB,GAAGJ,WAAW,CAACI,gBAAgB,EAAEE,GAAG,CAACZ,+BAA+B,CAAC;EACzF;EACA;EACA,MAAMa,SAAS,GAAG;IACd,GAAGP,WAAW;IACdQ,SAAS,EAAEjB,uBAAuB,CAACS,WAAW,CAACQ,SAAS,CAAC;IACzDJ;EACJ,CAAC;EACD;EACA,MAAMK,UAAU,GAAG,CAAC,CAAC;EACrB;AACJ;AACA;AACA;EACI,IAAIR,kBAAkB,EAAE;IACpB,IAAI,EAAE,MAAMR,+BAA+B,CAAC,CAAC,CAAC,EAAE;MAC5C,MAAMU,KAAK,CAAC,4CAA4C,CAAC;IAC7D;IACA;IACA,MAAMO,cAAc,GAAGC,QAAQ,CAACC,gBAAgB,CAAC,iCAAiC,CAAC;IACnF;IACA,IAAIF,cAAc,CAACL,MAAM,GAAG,CAAC,IAAIH,0BAA0B,EAAE;MACzD,MAAMC,KAAK,CAAC,mGAAmG,CAAC;IACpH;IACA;IACA;IACAM,UAAU,CAACI,SAAS,GAAG,aAAa;IACpC;IACAN,SAAS,CAACH,gBAAgB,GAAG,EAAE;EACnC;EACA;EACAK,UAAU,CAACF,SAAS,GAAGA,SAAS;EAChC;EACAE,UAAU,CAACK,MAAM,GAAGlB,oBAAoB,CAACmB,oBAAoB,CAAC,CAAC;EAC/D;EACA,IAAIC,UAAU;EACd,IAAI;IACAA,UAAU,GAAI,MAAMC,SAAS,CAACC,WAAW,CAACC,GAAG,CAACV,UAAU,CAAE;EAC9D,CAAC,CACD,OAAOW,GAAG,EAAE;IACR,MAAMzB,2BAA2B,CAAC;MAAE0B,KAAK,EAAED,GAAG;MAAErB,OAAO,EAAEU;IAAW,CAAC,CAAC;EAC1E;EACA,IAAI,CAACO,UAAU,EAAE;IACb,MAAM,IAAIb,KAAK,CAAC,kCAAkC,CAAC;EACvD;EACA,MAAM;IAAEmB,EAAE;IAAEC,KAAK;IAAEC,QAAQ;IAAEC;EAAK,CAAC,GAAGT,UAAU;EAChD,IAAIU,UAAU,GAAGC,SAAS;EAC1B,IAAIH,QAAQ,CAACE,UAAU,EAAE;IACrBA,UAAU,GAAGpC,uBAAuB,CAACkC,QAAQ,CAACE,UAAU,CAAC;EAC7D;EACA;EACA,OAAO;IACHJ,EAAE;IACFC,KAAK,EAAEjC,uBAAuB,CAACiC,KAAK,CAAC;IACrCC,QAAQ,EAAE;MACNI,iBAAiB,EAAEtC,uBAAuB,CAACkC,QAAQ,CAACI,iBAAiB,CAAC;MACtEC,cAAc,EAAEvC,uBAAuB,CAACkC,QAAQ,CAACK,cAAc,CAAC;MAChEC,SAAS,EAAExC,uBAAuB,CAACkC,QAAQ,CAACM,SAAS,CAAC;MACtDJ;IACJ,CAAC;IACDD,IAAI;IACJM,sBAAsB,EAAEf,UAAU,CAACgB,yBAAyB,CAAC,CAAC;IAC9DC,uBAAuB,EAAEpC,yBAAyB,CAACmB,UAAU,CAACiB,uBAAuB;EACzF,CAAC;AACL","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}